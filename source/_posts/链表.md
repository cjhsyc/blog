---
title: 链表
date: 2022-05-16 21:28:11
categories: [数据结构]
tags:
- 链表
---

# 单链表反转

```js
function Node(value, next) {
  this.value = value
  this.next = next
}

const n1 = new Node(1)
n1.next = new Node(2)
n1.next.next = new Node(3)

function reverse(head) {
  let pre = null
  let next = null
  while (head) {
    next = head.next
    head.next = pre
    pre = head
    head = next
  }
  return pre
}

let n2 = reverse(n1)
while (n2) {
  console.log(n2.value) //3 2 1
  n2 = n2.next
}
```

# 双向链表反转

```js
function DoubleNode(value,last,next){
  this.value = value
  this.last = last
  this.next = next
}

let n1 = new DoubleNode(1,null)
n1.next = new DoubleNode(2,n1)
n1.next.next = new DoubleNode(3,n1.next)

function reverseDouble(head){
  let pre = null
  let next = null
  while (head){
    next = head.next
    head.next = pre
    head.last = next
    pre = head
    head = next
  }
  return pre
}
```

# K 个一组翻转链表

`leetcode`上的题目： [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```js
var reverseKGroup = function(head, k) {
  let start = head
  let end = getGroupEnd(start,k)
  if(!end){
    return start
  }
  head = end
  reverse(start,end)
  let lastEnd = start
  while(start.next){
    start = start.next
    end = getGroupEnd(start,k)
    if(!end){
      return head
    }
    reverse(start,end)
    lastEnd.next = end
    lastEnd = start
  }
  return head
};

function getGroupEnd(start,k){
  while(--k > 0 && start){
    start = start.next
  }
  return start
}

function reverse(start,end){
  let cur = start
  let pre = null
  let next = null
  while(start != end){
    next = start.next
    start.next = pre
    pre = start
    start = next
  }
  next = start.next
  start.next = pre
  cur.next = next
}
```

# 有序链表合并

`leetcode`上的题目：[合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```js
var mergeTwoLists = function (list1, list2) {
  if (!list1 || !list2) {
    return list1 ? list1 : list2
  }
  let head = list1.val < list2.val ? list1 : list2
  let cur1 = head.next
  let cur2 = head === list1 ? list2 : list1
  let pre = head
  while (cur1 && cur2) {
    if (cur1.val < cur2.val) {
      pre.next = cur1
      cur1 = cur1.next
    } else {
      pre.next = cur2
      cur2 = cur2.next
    }
    pre = pre.next
  }
  pre.next = cur1 ? cur1 : cur2
  return head
};
```
