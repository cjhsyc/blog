---
title: pnpm特点
date: 2022-11-04 15:16:02
categories: 前端工程化
tags:
- pnpm
- monorepo
---

# pnpm

`pnpm` 本质上就是一个包管理器，这一点跟 `npm/yarn` 没有区别，但它作为杀手锏的两个优势在于:

- 包安装速度极快
- 高效利用磁盘空间

# 特点

## 速度快

`pnpm`在绝多大数场景下，包安装的速度都是明显优于 `npm/yarn`，速度会比 `npm/yarn` 快 2-3 倍。

## 高效利用磁盘空间

`pnpm` 内部使用`基于内容寻址`的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:

- 不会重复安装同一个包。用 `npm/yarn` 的时候，如果 100 个项目都依赖 `lodash`，那么 `lodash` 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 `pnpm` 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 `hardlink`(硬链接)。
- 即使一个包的不同版本，`pnpm` 也会极大程度地复用之前版本的代码。举个例子，比如 `lodash` 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 `hardlink`，仅仅写入那`一个新增的文件`。

## 支持 monorepo

之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 `monorepo` 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的`packages`目录下，那么一个子项目就代表一个`package`。

`pnpm` 与 `npm/yarn` 另外一个很大的不同就是支持了 `monorepo`，体现在各个子命令的功能上，比如在根目录下 `pnpm add A -r`, 那么所有的 package 中都会被添加 A 这个依赖，当然也支持 `--filter`字段来对 package 进行过滤。

## 安全性高

之前在使用 `npm/yarn` 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。因此会出现这种非法访问的情况。但 `pnpm` 脑洞特别大，自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性。

# 依赖管理

## npm/yarn

执行 `npm/yarn install`之后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:

- 将依赖包的版本区间解析为某个具体的版本号
- 下载对应版本依赖的 tar 包到本地离线镜像
- 将依赖从离线镜像解压到本地缓存
- 然后，对应的包就会到达项目的`node_modules`当中

这些依赖在`node_modules`内部是什么样的目录结构呢：

在 `npm1`、`npm2` 中呈现出的是嵌套结构，比如下面这样:

```
node_modules
└─ foo
   ├─ index.js
   ├─ package.json
   └─ node_modules
      └─ bar
         ├─ index.js
         └─ package.json
```

如果 `bar` 当中又有依赖，那么又会继续嵌套下去。试想一下这样的设计存在什么问题:

1. 依赖层级太深，会导致文件路径过长的问题，尤其在 window 系统下。
2. 大量重复的包被安装，文件体积超级大。比如跟 `foo` 同级目录下有一个`baz`，两者都依赖于同一个版本的`lodash`，那么 `lodash` 会分别在两者的 node_modules 中被安装，也就是重复安装。
3. 模块实例不能共享。比如 React 有一些内部变量，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的 bug。

接着，从 `npm3` 开始，包括 `yarn`，都着手来通过`扁平化依赖`的方式来解决这个问题。

相比之前的`嵌套结构`，现在的目录结构类似下面这样:

```
node_modules
├─ foo
|  ├─ index.js
|  └─ package.json
└─ bar
   ├─ index.js
   └─ package.json
```

所有的依赖都被拍平到`node_modules`目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的`node_modules`当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。

之前的问题是解决了，但它照样存在诸多问题：

- 依赖结构的**不确定性**。
- 扁平化算法本身的**复杂性**很高，耗时较长。
- 项目中仍然可以**非法访问**没有声明过依赖的包

依赖结构的`不确定`问题，也是 `lock 文件`诞生的原因，无论是`package-lock.json`(`npm 5.x`才出现)还是`yarn.lock`，都是为了保证 install 之后都产生确定的`node_modules`结构。

尽管如此，`npm/yarn` 本身还是存在`扁平化算法复杂`和`package 非法访问`的问题，影响性能和安全。

## pnpm

### hard link 硬链接

计算机里面一个叫做 Hard link 的机制，hard link 使得用户可以通过不同的路径引用方式去找到某个文件。`pnpm` 会在全局的 `store` 目录里存储项目 `node_modules` 文件的 hard links 。

因为这样一个机制，导致每次安装依赖的时候，如果是个相同的依赖，有好多项目都用到这个依赖，那么这个依赖实际上最优情况（即版本相同）只用安装一次。使用 `pnpm` 对项目安装依赖的时候，如果某个依赖在 `sotre` 目录中存在，那么就会直接从 `store` 目录里面去 hard-link，避免了二次安装带来的时间消耗，如果依赖在 `store` 目录里面不存在的话，就会去下载一次。

### 软连接（符号链接）

TODO





参考：

[关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?](https://juejin.cn/post/6932046455733485575?share_token=863f4c48-e720-458f-935b-b7b78fc119cc)
